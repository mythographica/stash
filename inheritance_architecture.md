# Architecture of Prototype Inheritance in JavaScript

I'm stuck. Yes, I stuck. I did it the first once, then second, third and finally just ... stuck. It blows my mind, though, I think this should be coded somehow, yes. It might be the general purpose library or command line interface, whatever. It might combine the way of usage. And it is about how we code algorythms, for sure we shall live with it.

For the vista of re-vision let assume it is a secret that [Algorithm](https://en.wikipedia.org/wiki/Algorithm) is a "sequence" ... *of of [well-defined](https://en.wikipedia.org/wiki/Well-defined), computer-implementable instructions* ... and so on ...

And there is [Topological sorting](https://en.wikipedia.org/wiki/Topological_sorting) and all the way we do instructions is a pipline of data processing.

And what if there is a thing we might avoid thinking of as of a sequence? Undoubtedly from well known [Black hole Information Paradox](https://en.wikipedia.org/wiki/Black_hole_information_paradox) we might probably review our understanding of "everything" as a "sequence". But from the other side there is [Poincaré conjecture](https://en.wikipedia.org/wiki/Poincaré_conjecture) and there is an impact to the solutions where we should throw out the Ideas with broken Topology.

In an attempt to prepare us for the next step here is other nice **beginner's** topic: [Composition over Inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance), and here is same title video from [Fun Fun Functions](https://www.youtube.com/watch?v=wfMtDGfHWpA).

And the hidden question there: 
**Is Composition a Sequence or Not**?

Well... we might obviously converse it is a **technique** to combine reusable sequence part of algorithms to make them work more efficiently in a whole structure.

> &laquo;&nbsp;[But it's not that easy when your soul is torn in two](https://en.wikipedia.org/wiki/Stop!_(Sam_Brown_song))&nbsp;&raquo;

I mean, reusable parts is a great idea, all that stuff which reusably [Controls the flow](https://en.wikipedia.org/wiki/Control_flow#Loops) of our code: Loops, or [Recursions](https://en.wikipedia.org/wiki/Recursion_(computer_science)) or... nevermind, they are made for Greater Good. [Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator) with [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) and all that async'ish stuff are great helpers.

Though when we will climb up and down on the "ladder of [abstraction](https://en.wikipedia.org/wiki/Abstraction)" probably we will see the whole thing, but there might be hidden "[black hole's event horisons](https://en.wikipedia.org/wiki/Event_horizon)" which we will probably hardly overcome with thinking of code "reusability".

I mean "reusability" is not a thing, but "sequence" is a Thing, very natural thing with a lot of characteristics, for example "[State](https://en.wikipedia.org/wiki/State_(computer_science))" or "[Observability](https://en.wikipedia.org/wiki/Profiling_(computer_programming))" and "[Measurements](https://en.wikipedia.org/wiki/Measurement)". And all this sequenced async stuff is done narrowing calculations with raw data or even with well prepared Information or odd it might be "of the bit" eventually just feelings of the kinds.

Then well, when we shall connect that feelings of our mind with sequence, can we get the idea of beauty? Shold we reuse it? Or should we repeat it recursively for whatever this might be meaning then?

I don't even understand what I'm writing, this might be complete noise, or one of the definitions of "[42](https://simple.wikipedia.org/wiki/42_(answer))". And indeed it is proven by [Gödel's incompleteness theorems](https://en.wikipedia.org/wiki/Gödel's_incompleteness_theorems).

And 42 itself is a serial number of [multiplier](https://simple.wikipedia.org/wiki/Asterisk) symbol of [ASCI](https://en.wikipedia.org/wiki/ASCI) symbols table, which is then connected to "[...ad Astra](https://en.wikipedia.org/wiki/Per_aspera_ad_astra)" in [Latin](https://en.wikipedia.org/wiki/Latin), and then to [Astarte](https://en.wikipedia.org/wiki/Astarte) or Ishtar, the godess of love, 
power and war from the Bronze Age. And she is then an avatar of [Shakti](https://en.wikipedia.org/wiki/Sati_(Hindu_goddess)) or [Pravati](https://en.wikipedia.org/wiki/Parvati) in [Hinduism](https://en.wikipedia.org/wiki/Hinduism).

And here we might think [Cosmos](https://en.wikipedia.org/wiki/Cosmos) and topology and time are connected to algorythms and lifecycle of data.

And what if we can combine all this flavors to a [Chain of responsibility](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern) with declarative [Meta-programming](https://en.wikipedia.org/wiki/Metaprogramming)?

This definetely might be coded...
We indeed can craft code allowing us to aid information retention during data lifecycle... But the question is still there: what is a Sequence? 

What is of that piece of minimal abstraction we should re-use avoiding of [Entropy](https://en.wikipedia.org/wiki/Entropy_(information_theory))? Where information retention is not so enough? And should that hidden piece be sacred or not?

Describing algorythm as a [Narrative](https://en.wikipedia.org/wiki/Narrative) story and [Plot](https://en.wikipedia.org/wiki/Plot_(narrative)) we might convince then the aspect of [chronological order of the events](https://en.wikipedia.org/wiki/Fabula_and_syuzhet) in the meaning of [Chronotope](https://en.wikipedia.org/wiki/Chronotope) is very tightly coupled with the concept of [Grammatical modifier](https://en.wikipedia.org/wiki/Grammatical_modifier) in the meaning of [Function composition](https://en.wikipedia.org/wiki/Function_composition_(computer_science)) and [Object composition](https://en.wikipedia.org/wiki/Object_composition) at the sequence of time.

And the concept of Modifier in Software Engineering describes exactly what we are seeking for. There is a lot of them, here are just a few of may other examples:
* for **Access**: Private, Static, Protected, Internal ...
* for **Type**: Signed, Unsigned,  Short, Long ...
* **Behaviour**: `'use strict';`, "... throws" to be "thrown"

And each one of them describes an answer to the question "what will happen": so, this is a setting for Chronotope. Despite of [Type Systems](https://en.wikipedia.org/wiki/Type_system) answering the question "what is it", modifiers answers the questions "how are they". So shouldn't then there be the a question "when they are",  and "why they are" and even "whose are they" in [Runtime](https://en.wikipedia.org/wiki/Runtime_(program_lifecycle_phase))?

For sure, the answers are "Yes" for all that questions, it is just what we are doing as a developers. Crafting our algorythms we describe the answers to that questions, we always make:
* extracting or consuming data,
* transforming data from one form to the other,
* and then we might be storing the data or loading it somewhere else.

And seems nothing is wrong here, but... why then we have a lot of bugs everyday, isn't this is a point we might be missing something? Seems there might be some hidden review point and we shall find it for the Greater Good in a memory of the past.

Indeed, then here I stuck seeking for solution.

And then I remembered... It was far ago, more than 20 years, as if should it be me getting back to the past as mystic re-vision of my own future. And I got it just few month ago, obviously by a chance. To be honest it was not me who found it. I just felt it is what am I seeking for. And even more, I felt it only now, passing 20 years of seeking for nothing, being able to touch it anywhen. I can't remember that day well, it was a moment of summer obligatory computer classes after my first University term. There was a file leaved by somewone else on my clasroom's desktop with MS Windows NT. And I do remember when I saw that code I felt like complete dumb. I was unable to get the idea then, though it was clear enough, and I can describe it very well even now. There was [Factory function](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)), which was making a function and then that function returned to the variable was constructed, something like this:

```javascript
    // to the glory of Mnemosyne
    function Factory (previous) {
      function MyConstructor (state) {
        this.state = state;
      };
      MyConstructor.prototype = previous;
      return MyConstructor;
    };

    var initial = { state: 1 };
    var Constructor_1 = Factory(initial);
    var next1 = new Constructor_1(2);
    var Constructor_2 = Factory(next1);
    var next2 = new Constructor_2(3);
```

What have I missed was the `prototype` keyword and the meaning what it was doing. There was no debugging tools that times, and I was able to understand the final `.state` is `3` but it was hidden from me that all  previous states are there, inside of Prototype Chain of `next1` and `next2`:

![state of inheritance](https://raw.githubusercontent.com/mythographica/stash/master/img/inheritance.png)

And inspite I noticed the name of [Mnemosyne](https://en.wikipedia.org/wiki/Mnemosyne), cause it was very close to [Mnemonic](https://en.wikipedia.org/wiki/Mnemonic) and I knew this word from books of tricks and magic, I was unable to connect it with algorythm itself, thinking it was just a joke for some naughty girl.


Having very few competence, undoubtedly I thought the code is just garbage, but it was indeed Genius Masterpiece...